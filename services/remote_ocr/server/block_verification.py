"""Верификация и повторное распознавание пропущенных блоков"""
from __future__ import annotations

import json
import time
from pathlib import Path
from typing import Callable


from .logging_config import get_logger

logger = get_logger(__name__)

# Паттерн ошибки в ocr_text, генерируемый бэкендами при сбоях API
_ERROR_PREFIX = "[Ошибка"

# Пауза между retry для бэкендов с ограничением concurrency (Chandra/LM Studio)
_RETRY_DELAY_CHANDRA = 5


def _is_chandra_backend(backend) -> bool:
    """Проверить, является ли бэкенд Chandra (LM Studio)."""
    return type(backend).__name__ in ("ChandraBackend", "AsyncChandraBackend")


def _get_engine_name(backend) -> str:
    """Получить имя движка из бэкенда для логирования."""
    cls = type(backend).__name__
    name_map = {
        "ChandraBackend": "chandra",
        "AsyncChandraBackend": "chandra",
        "DatalabOCRBackend": "datalab",
        "OpenRouterBackend": "openrouter",
    }
    return name_map.get(cls, cls.lower())


def verify_and_retry_missing_blocks(
    result_json_path: Path,
    pdf_path: Path,
    work_dir: Path,
    ocr_backend,
    on_progress: Callable[[int, int], None] = None,
    job_id: str = None,
) -> bool:
    """
    Верификация блоков после OCR и повторное распознавание пропущенных.

    Args:
        result_json_path: путь к result.json
        pdf_path: путь к PDF файлу
        work_dir: рабочая директория
        ocr_backend: OCR backend для повторного распознавания (любой OCRBackend)
        on_progress: callback (current, total) для обновления прогресса

    Returns:
        True если были найдены и обработаны пропущенные блоки
    """
    if not result_json_path.exists():
        logger.warning(f"result.json не найден: {result_json_path}")
        return False

    with open(result_json_path, "r", encoding="utf-8") as f:
        result = json.load(f)

    engine_name = _get_engine_name(ocr_backend)

    # Находим блоки без OCR результата или с ошибками API
    missing_blocks = []
    for page in result.get("pages", []):
        for blk in page.get("blocks", []):
            block_type = blk.get("block_type", "text")
            block_id = blk.get("id", "")
            ocr_html = blk.get("ocr_html", "").strip()
            ocr_text = blk.get("ocr_text", "")
            category_code = blk.get("category_code", "")

            # Пропускаем штампы и image блоки (они обрабатываются отдельно)
            if category_code == "stamp" or block_type == "image":
                continue

            # Проверяем только текстовые и табличные блоки
            if block_type not in ["text", "table"]:
                continue

            # Блок нуждается в retry если: нет HTML ИЛИ ocr_text содержит ошибку API
            has_error = not ocr_html or ocr_text.startswith(_ERROR_PREFIX)
            if has_error:
                missing_blocks.append({
                    "block": blk,
                    "page_index": blk.get("page_index", 1) - 1,  # Конвертируем в 0-based
                    "reason": "api_error" if ocr_text.startswith(_ERROR_PREFIX) else "empty",
                })

    if not missing_blocks:
        logger.info("Все текстовые блоки распознаны")
        return False

    error_count = sum(1 for b in missing_blocks if b["reason"] == "api_error")
    empty_count = len(missing_blocks) - error_count
    logger.warning(
        f"Найдено {len(missing_blocks)} нераспознанных текстовых блоков "
        f"(пустых: {empty_count}, ошибок API: {error_count}), engine: {engine_name}"
    )

    # Создаём директорию для кропов
    retry_crops_dir = work_dir / "retry_crops"
    retry_crops_dir.mkdir(exist_ok=True)

    # Обрабатываем каждый блок отдельно
    from .pdf_streaming_core import StreamingPDFProcessor
    from rd_core.models import Block

    is_chandra = _is_chandra_backend(ocr_backend)
    successful_retries = 0

    with StreamingPDFProcessor(str(pdf_path)) as processor:
        for idx, item in enumerate(missing_blocks):
            # Вызываем callback прогресса перед обработкой блока
            if on_progress:
                on_progress(idx, len(missing_blocks))

            # Гарантируем отправку обновлений каждые 5 блоков
            if job_id and idx % 5 == 0:
                from .debounced_updater import get_debounced_updater
                get_debounced_updater(job_id).flush()

            blk_data = item["block"]
            block_id = blk_data["id"]
            reason = item["reason"]

            logger.info(
                f"[{idx+1}/{len(missing_blocks)}] Повторное распознавание блока "
                f"{block_id} ({reason}), engine: {engine_name}"
            )

            # Пауза перед retry для Chandra (LM Studio может быть перегружен)
            if is_chandra and idx > 0:
                time.sleep(_RETRY_DELAY_CHANDRA)

            try:
                # Создаём Block объект для crop
                block_obj, _ = Block.from_dict(blk_data, migrate_ids=False)

                # Вырезаем кроп
                crop = processor.crop_block_image(block_obj, padding=5)
                if not crop:
                    logger.warning(f"Не удалось создать кроп для блока {block_id}")
                    continue

                # Сохраняем кроп для отладки
                crop_path = retry_crops_dir / f"{block_id}.png"
                crop.save(crop_path, "PNG")

                # Отправляем на распознавание
                ocr_text = ocr_backend.recognize(crop)
                crop.close()

                if ocr_text and not ocr_text.startswith(_ERROR_PREFIX):
                    # Обновляем блок в result.json
                    blk_data["ocr_html"] = ocr_text
                    blk_data["ocr_text"] = ocr_text
                    blk_data["ocr_meta"] = {
                        "method": [f"retry_{engine_name}"],
                        "match_score": 100.0,
                        "marker_text_sample": "",
                    }
                    successful_retries += 1
                    logger.info(f"Блок {block_id} успешно распознан retry ({len(ocr_text)} символов)")
                else:
                    logger.warning(f"Блок {block_id} не распознан при retry: {ocr_text[:100] if ocr_text else 'пусто'}")

            except Exception as e:
                logger.error(f"Ошибка обработки блока {block_id}: {e}", exc_info=True)
                continue

    # Сохраняем обновлённый result.json
    if successful_retries > 0:
        with open(result_json_path, "w", encoding="utf-8") as f:
            json.dump(result, f, ensure_ascii=False, indent=2)
        logger.info(f"result.json обновлён ({successful_retries} блоков добавлено)")

        # Регенерируем HTML и MD
        _regenerate_output_files(result, work_dir, result_json_path)

    logger.info(f"Верификация завершена: {successful_retries}/{len(missing_blocks)} блоков восстановлено")
    return successful_retries > 0


def _regenerate_output_files(result: dict, work_dir: Path, result_json_path: Path):
    """Регенерировать HTML и MD после обновления result.json"""
    from .ocr_result_merger import regenerate_html_from_result, regenerate_md_from_result

    try:
        # Регенерируем HTML
        html_path = work_dir / "ocr_result.html"
        doc_name = result.get("pdf_path", "OCR Result")
        regenerate_html_from_result(result, html_path, doc_name=doc_name)
        logger.info(f"HTML регенерирован: {html_path}")

        # Регенерируем MD
        md_path = work_dir / "document.md"
        regenerate_md_from_result(result, md_path, doc_name=doc_name)
        logger.info(f"MD регенерирован: {md_path}")
    except Exception as e:
        logger.error(f"Ошибка регенерации файлов: {e}", exc_info=True)
