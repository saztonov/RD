# Кеширование аннотаций

## Проблема

При работе с обводками блоков возникали длительные подвисания из-за синхронного обращения к R2 при каждом изменении.

## Решение

Реализована система кеширования с асинхронной синхронизацией:

### Архитектура

```
┌─────────────────┐
│   UI Thread     │
│  (PageViewer)   │
└────────┬────────┘
         │ изменение обводки
         ▼
┌─────────────────┐
│ AnnotationCache │ ◄── мгновенное обновление в памяти
└────────┬────────┘
         │
         ├─► Локальное сохранение (0.5 сек) ──► ThreadPool
         │
         └─► Синхронизация R2 (3 сек) ──────► ThreadPool
```

### Компоненты

#### `AnnotationCache` (`app/gui/annotation_cache.py`)

- **Кеш в памяти**: `Dict[node_id, Document]`
- **Отложенное локальное сохранение**: 0.5 секунды после последнего изменения
- **Отложенная синхронизация R2**: 3 секунды после последнего изменения
- **Фоновые потоки**: ThreadPoolExecutor для неблокирующих операций

#### Интеграция

1. **FileAutoSaveMixin** - упрощен, использует кеш вместо прямого сохранения
2. **MainWindow** - подключает сигналы кеша при инициализации
3. **FileOperationsMixin** - инициализирует кеш при загрузке аннотации

### Workflow

1. **Изменение обводки**:
   - `_auto_save_annotation()` → `cache.mark_dirty(node_id)` (мгновенно)
   - UI не блокируется

2. **Через 0.5 сек**:
   - Локальное сохранение в фоновом потоке
   - Файл `*_annotation.json` обновлен

3. **Через 3 сек**:
   - Синхронизация с R2 в фоновом потоке
   - Обновление БД (node_files, has_annotation)
   - Сигнал `synced` → обновление UI

### Преимущества

- ✅ Мгновенный отклик UI при обводках
- ✅ Автоматическое накопление изменений (debounce)
- ✅ Надежность: локальное сохранение + R2
- ✅ Минимизация запросов к R2
- ✅ Graceful degradation при проблемах с сетью

### API

```python
from app.gui.annotation_cache import get_annotation_cache

cache = get_annotation_cache()

# Установить аннотацию в кеш
cache.set(node_id, document, pdf_path, r2_key, ann_path)

# Пометить как измененную (запустит отложенное сохранение)
cache.mark_dirty(node_id)

# Принудительная синхронизация
cache.force_sync(node_id)
cache.force_sync_all()

# Очистка
cache.clear(node_id)
```

### Сигналы

```python
cache.synced.connect(on_synced)          # node_id
cache.sync_failed.connect(on_failed)     # node_id, error
```

### Настройки

```python
cache._local_save_delay = 0.5  # секунды
cache._sync_delay = 3.0         # секунды
```

## Тестирование

1. Открыть PDF с аннотацией
2. Быстро изменять обводки блоков (перетаскивание вершин полигона)
3. Проверить отсутствие подвисаний
4. Через 3 секунды проверить синхронизацию с R2

## Миграция

Изменения обратно совместимы. Старый код продолжит работать, но будет использовать новый кеш автоматически.
